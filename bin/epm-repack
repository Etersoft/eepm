#!/bin/sh
#
# Copyright (C) 2017-2018, 2020  Etersoft
# Copyright (C) 2017-2018, 2020  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

load_helper epm-sh-altlinux
load_helper epm-assure
load_helper epm-status

[ -n "$EPM_REPACK_SCRIPTS_DIR" ] || EPM_REPACK_SCRIPTS_DIR="$CONFIGDIR/repack.d"

__epm_have_repack_rule()
{
    # FIXME: use real way (for any archive)
    local pkgname="$(epm print name for package "$1" 2>/dev/null)"
    local repackcode="$EPM_REPACK_SCRIPTS_DIR/$pkgname.sh"
    [ -s "$repackcode" ]
}

__epm_check_repack_rule()
{
    # skip repacking on non ALT systems
    [ "$BASEDISTRNAME" = "alt" ] || return 1

    local i
    for i in $* ; do
        # skip for packages built with repack
        epm_status_repacked "$i" && return 1

        __epm_have_repack_rule "$i" || return 1
    done
    return 0
}

__epm_check_if_needed_repack()
{
    __epm_check_repack_rule "$@" || return
    local pkgname="$(epm print name for package "$1")"
    warning 'There is repack rule for $pkgname package. It is better install this package via epm install --repack or epm play.'
}

# arg: rpm or deb
# fills split_replaced_pkgs with packages of that type
__epm_split_by_pkg_type()
{
    local type="$1"
    shift

    split_replaced_pkgs=''

    for pkg in "$@" ; do
        [ "$(get_package_type "$pkg")" = "$type" ] || return 1
        [ -e "$pkg" ] || fatal "Can't read $pkg"
        split_replaced_pkgs="$split_replaced_pkgs $pkg"
    done

    [ -n "$split_replaced_pkgs" ]
}


__check_stoplist()
{
    local pkg="$1"
    local alf="$CONFIGDIR/repackstoplist.list"
    [ -s "$alf" ] || return 1
    [ -n "$pkg" ] || return 1
    grep -E -q "^$1$" $alf
}

__convert_packrule_to_regexp()
{
    local tmpalf
    tmpalf="$(mktemp)" || fatal
    # copied from eget's filter_glob
    # check man glob
    # remove commentÑ‹ and translate glob to regexp
    grep -v "^[[:space:]]*#" "$1" | grep -v "^[[:space:]]*$" | sed -e "s|\*|.*|g" -e "s|?|.|g" >$tmpalf
    echo "$tmpalf"
}

# fill __PACKRULE if $1 in packrules.list
__check_packrule()
{
    local pkg="$1"
    local alf="$CONFIGDIR/packrules.list"
    [ -s "$pkg" ] || return 1
    [ -s "$alf" ] || return 1

    local tmpalf=$(__convert_packrule_to_regexp "$alf")
    remove_on_exit $tmpalf
    __PACKRULE="$(awk -v s="$pkg" 'BEGIN{FS=" "} s ~ $2  {print $1}' "$tmpalf")"
    rm $tmpalf
    [ -n "${__PACKRULE}" ]
    return
}

# arg: <package file>
# sets:
#   alpkg      - resulted package file name in the current dir
#   SUBGENERIC - name of generic file's extension
__prepare_source_package()
{
    local pkg="$1"

    alpkg=$(basename $pkg)

    # TODO: use func for get name from deb pkg
    # TODO: epm print name from deb package
    local pkgname="$(echo $alpkg | sed -e "s|_.*||")"

    # TODO: use stoplist only for deb?
    [ -z "$force" ] && __check_stoplist $pkgname && fatal 'Please use official package instead of $alpkg repacking (It is not recommended to use --force to skip this checking.'

    SUBGENERIC=''

    if rhas "$alpkg" "\.(rpm|deb)$" ; then
        # skip packing for supported directly: rpm and deb
        return
    fi

    # convert tarballs to tar (for alien)
    load_helper epm-pack

    # they will fill $returntarname

    if __check_packrule "$alpkg" ; then
        __epm_pack_run_handler ${__PACKRULE} "$pkg"
    elif rihas "$alpkg" "\.AppImage$" ; then
        # big hack with $pkg_urls_downloaded (it can be a list, not a single url)
        __epm_pack_run_handler generic-appimage "$pkg" "" "$pkg_urls_downloaded"
        SUBGENERIC='appimage'
    elif rhas "$alpkg" "\.snap$" ; then
        __epm_pack_run_handler generic-snap "$pkg"
        SUBGENERIC='snap'
    else
        __epm_pack_run_handler generic-tar "$pkg"
        SUBGENERIC='tar'
    fi

    # it is possible there are a few files, we don't support it
    [ -s "$returntarname" ] || fatal 'Can'\''t read result from pack: $returntarname is not a readable file.'

    alpkg=$(basename $returntarname)
    # FIXME: looks like a hack with current dir
    if [ "$(pwd)" != "$(dirname "$returntarname")" ] ; then
        cp $verbose $returntarname $alpkg
        [ -r "$returntarname.eepm.yaml" ] && cp $verbose $returntarname.eepm.yaml $alpkg.eepm.yaml
    fi
}



# used in epm install
__epm_repack_single()
{
    local pkg="$1"
    local repack_script="$2"
    local packversion="$3"
    local packrelease="$4"

    if [ -n "$repack_script" ] && [ ! -s "$EPM_REPACK_SCRIPTS_DIR/$repack_script.sh" ]; then
        fatal "Repack script $repack_script.sh not found in $EPM_REPACK_SCRIPTS_DIR"
    fi

    case $PKGFORMAT in
        rpm)
            load_helper epm-repack-rpm
            __epm_repack_to_rpm "$pkg" "$repack_script" "$packversion" "$packrelease" || return
            ;;
        deb)
            if [ -n "$repack_script" ] || __epm_have_repack_rule "$pkg" ; then
                # we have repack rules only for rpm, so use rpm step in any case
                load_helper epm-repack-rpm
                load_helper epm-repack-deb
                __epm_repack_to_rpm "$pkg" "$repack_script" "$packversion" "$packrelease" || return
                [ -n "$repacked_pkg" ] || return
                __epm_repack_to_deb $repacked_pkg || return
            else
                load_helper epm-repack-deb
                __epm_repack_to_deb "$pkg" || return
            fi
            ;;
        *)
            fatal '$PKGFORMAT is not supported for repack yet'
            ;;
    esac

    return 0
}

# fill repacked_pkgs
__epm_repack()
{
    local pkg
    repacked_pkgs=''
    for pkg in $* ; do
        __epm_repack_single "$pkg" || fatal 'Error with $pkg repacking.'
        [ -n "$repacked_pkgs" ] && repacked_pkgs="$repacked_pkgs $repacked_pkg" || repacked_pkgs="$repacked_pkg"
    done
}


__epm_repack_if_needed()
{
    # return 1 if there is a package in host package format
    __epm_split_by_pkg_type $PKGFORMAT "$@" && return 1

    __epm_repack "$@"
    return 0
}

epm_repack()
{
    local repack_script=""
    local packversion=""
    local packrelease=""
    local pkg_files=""
    local pkg_urls=""
    repacked_pkgs=""

    # Check for script (optional) and package
    if [ -n "$1" ]; then
        if [ -s "$EPM_REPACK_SCRIPTS_DIR/$1.sh" ]; then
            repack_script="$1"
            shift
            # Next argument must be package
            if [ -n "$1" ]; then
                if [ -e "$1" ] || is_url "$1" || [ -d "$1" ]; then
                    pkg_files="$1"
                else
                    pkg_urls="$1"
                fi
                shift
            else
                fatal "Package file or URL required after script name"
            fi
        else
            # No script, first argument is package
            if [ -e "$1" ] || is_url "$1" || [ -d "$1" ]; then
                pkg_files="$1"
            else
                pkg_urls="$1"
            fi
            shift
        fi
    else
        fatal "At least one argument (package file or URL) is required"
    fi

    # Check for version-release (optional)
    if [ -n "$1" ]; then
        if echo "$1" | grep -qE '^[0-9]+(\.[0-9]+)*(-[0-9a-zA-Z.-]+)?$'; then
            packversion=$(echo "$1" | sed -e 's|-\([0-9a-zA-Z.-]\+\)$||')
            packrelease=$(echo "$1" | sed -e 's|^.*-\([0-9a-zA-Z.-]\+\)$|\1|')
            shift
        else
            pkg_urls="$pkg_urls $1"
            warning "Invalid version format: $1, treating as URL"
            shift
        fi
    fi

    # Append remaining arguments as package files or URLs
    while [ -n "$1" ]; do
        if [ -e "$1" ] || is_url "$1" || [ -d "$1" ]; then
            pkg_files="$pkg_files $1"
        else
            pkg_urls="$pkg_urls $1"
            warning "Invalid argument (not a file, URL, or version): $1"
        fi
        shift
    done

    if [ -n "$pkg_urls" ] || is_url "$pkg_files"; then
        load_helper epm-download
        pkg_urls="$pkg_urls $pkg_files"
        __download_pkg_urls
        pkg_files="$pkg_files_downloaded"
        pkg_urls=""
    fi

    if [ -z "$pkg_files" ]; then
        info "Empty repack list was skipped"
        return 22
    fi

    for pkg in $pkg_files; do
        if [ ! -e "$pkg" ] && ! is_url "$pkg"; then
            warning "Can't find package file $pkg"
            return 22
        fi
        __epm_repack_single "$pkg" "$repack_script" "$packversion" "$packrelease" || { warning "Failed to repack $pkg" >&2; return 1; }
        [ -n "$repacked_pkg" ] && repacked_pkgs="$repacked_pkgs $repacked_pkg"
    done

    if [ -n "$repacked_pkgs" ]; then
        if [ -n "$install" ] ; then
            epm install $repacked_pkgs
            return
        fi

        cp $repacked_pkgs "$EPMCURDIR"
        if [ -z "$quiet" ] ; then
            echo
            message "Adapted packages:"
            for i in $repacked_pkgs ; do
                echo "    $EPMCURDIR/$(basename "$i")"
            done
        fi
    fi

}
